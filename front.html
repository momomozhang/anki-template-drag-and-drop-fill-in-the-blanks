<div class="learning-interface">
    <!-- Main Content Area -->
    <main class="content-area">
        <div class="exercise-text" id="exercise-text">
            <!-- Text with form-like input elements -->
        </div>
        
        <div class="exercise-controls">
            <button class="action-btn primary" id="show-answers-btn">Show Answers</button>
            <button class="action-btn secondary" id="reset-btn">Reset</button>
        </div>
        
        <!-- Available Items - positioned below buttons -->
        <aside class="item-bank">
            <div class="item-collection" id="item-collection">
                <!-- Draggable items in horizontal layout -->
            </div>
        </aside>
    </main>
</div>

{{#Question}}
<!-- Store field content in hidden div -->
<div id="question-data" style="display: none;">{{Question}}</div>

<script>
(function() {
    // Global state for drag-and-drop functionality
    var studyState = {
        correctAnswers: new Map(),
        userAnswers: new Map(),
        idGenerationLock: false,
        usedIds: new Set()
    };

// Shared utility functions to prevent code duplication
function findMaxExistingNumber(content) {
    var maxNum = 0;
    content.replace(/\[\[d(\d+)::((?:(?!\]\])[\s\S])*)\]\]/g, function(match, num) {
        var parsedNum = parseInt(num, 10);
        if (!isNaN(parsedNum) && parsedNum > 0) {
            maxNum = Math.max(maxNum, parsedNum);
        }
    });
    return maxNum;
}

// Shared ID generation factory to prevent code duplication
function createIdGenerator(startId) {
    var nextAutoId = startId || 1;
    
    return function generateSafeId(num) {
        // Prevent race conditions in ID generation
        if (studyState.idGenerationLock) {
            // Wait for lock to be released
            var attempts = 0;
            while (studyState.idGenerationLock && attempts < 100) {
                attempts++;
            }
        }
        
        studyState.idGenerationLock = true;
        
        try {
            var blankId;
            if (num && num.length > 0) {
                // Legacy pattern: use original number
                blankId = 'd' + num;
                if (studyState.usedIds.has(blankId)) {
                    // Handle duplicate IDs
                    var counter = 1;
                    while (studyState.usedIds.has(blankId + '_' + counter)) {
                        counter++;
                    }
                    blankId = blankId + '_' + counter;
                }
            } else {
                // New pattern: generate sequential ID
                do {
                    blankId = 'd' + nextAutoId;
                    nextAutoId++;
                } while (studyState.usedIds.has(blankId));
            }
            
            studyState.usedIds.add(blankId);
            return blankId;
        } finally {
            studyState.idGenerationLock = false;
        }
    };
}

// Initialize study mode
function initializeStudyMode() {
    parseQuestion();
    createDraggableItems();
    resetStudyState();
    attachDragAndDropEvents();
    attachControlEvents();
}

// Parse question field and create inline drop zones with HTML formatting preservation
function parseQuestion() {
    var questionData = document.getElementById('question-data');
    var exerciseText = document.getElementById('exercise-text');
    
    if (!questionData || !exerciseText) {
        exerciseText.innerHTML = '<p style="color: red;">ERROR: Missing DOM elements</p>';
        return;
    }
    
    // Get both content types
    var textContent = questionData.textContent;
    var innerHTML = questionData.innerHTML;
    
    studyState.correctAnswers.clear();
    
    // Use textContent for validation (preserve working logic)
    var questionField = validateAndSanitizePattern(textContent);
    
    if (!questionField || questionField.trim() === '' || questionField === '{{Question}}') {
        exerciseText.innerHTML = '<p style="color: #666; font-style: italic;">No question content found. Please add content to your Question field.</p>';
        return;
    }
    
    // Test HTML processing vs text processing
    var htmlProcessingResult = '';
    var htmlProcessingSuccess = false;
    var textProcessingResult = '';
    var textProcessingSuccess = false;
    var processingMethod = 'none';
    
    // Test HTML processing
    try {
        if (innerHTML && innerHTML !== textContent) {
            // Validate and sanitize HTML content
            innerHTML = validateAndSanitizePattern(innerHTML);
            
            // HTML formatting exists - use smart regex replacement
            var htmlAnswers = new Map();
            var nextAutoId = 1;
            
            // Use shared ID generation function
            var generateSafeId = createIdGenerator(nextAutoId);
            
            // Find max existing number first
            var maxNum = findMaxExistingNumber(innerHTML);
            nextAutoId = maxNum + 1;
            
            // Process both patterns in one pass
            var htmlProcessed = innerHTML.replace(/\[\[d(\d*)::((?:(?!\]\])[\s\S])*)\]\]/g, function(match, num, text) {
                var blankId = generateSafeId(num);
                htmlAnswers.set(blankId, text);
                return '<span class="answer-input" data-blank-id="' + blankId + '"></span>';
            });
            
            if (htmlProcessed !== innerHTML) {
                htmlProcessingResult = htmlProcessed;
                htmlProcessingSuccess = true;
                processingMethod = 'html';
                
                // Copy HTML answers to global state
                htmlAnswers.forEach(function(value, key) {
                    studyState.correctAnswers.set(key, value);
                });
            }
        }
    } catch (error) {
        htmlProcessingResult = 'HTML processing error: ' + error.message;
        htmlProcessingSuccess = false;
    }
    
    // Test text processing (fallback)
    try {
        var textAnswers = new Map();
        var nextAutoId = 1;
        
        // Use shared ID generation function for text processing
        var generateSafeTextId = createIdGenerator(nextAutoId);
        
        // Find max existing number first
        var maxNum = findMaxExistingNumber(questionField);
        nextAutoId = maxNum + 1;
        
        // Process both patterns in one pass
        var textProcessed = questionField.replace(/\[\[d(\d*)::((?:(?!\]\])[\s\S])*)\]\]/g, function(match, num, text) {
            var blankId = generateSafeTextId(num);
            textAnswers.set(blankId, text);
            return '<span class="answer-input" data-blank-id="' + blankId + '"></span>';
        });
        
        if (textProcessed !== questionField) {
            textProcessingResult = textProcessed;
            textProcessingSuccess = true;
            
            // Use text answers if HTML processing failed
            if (!htmlProcessingSuccess) {
                processingMethod = 'text';
                textAnswers.forEach(function(value, key) {
                    studyState.correctAnswers.set(key, value);
                });
            }
        } else {
            textProcessingResult = questionField + '<br><br><em style="color: #666;">No drag-drop blanks found. Use the add-on to create [[d::text]] syntax.</em>';
            textProcessingSuccess = true;
            processingMethod = 'text';
        }
    } catch (error) {
        textProcessingResult = 'Text processing error: ' + error.message;
        textProcessingSuccess = false;
    }
    
    // Use the best available processing result
    var finalContent = '';
    if (htmlProcessingSuccess) {
        finalContent = htmlProcessingResult;
    } else if (textProcessingSuccess) {
        finalContent = textProcessingResult;
    } else {
        finalContent = '<p style="color: red;">ERROR: Both processing methods failed</p>';
    }
    
    exerciseText.innerHTML = sanitizeHtml(finalContent);
}

// Create draggable items from Question field syntax with HTML formatting preservation
function createDraggableItems() {
    var questionData = document.getElementById('question-data');
    var itemCollection = document.getElementById('item-collection');
    
    if (!questionData || !itemCollection) {
        return;
    }
    
    // Get both content types
    var textContent = questionData.textContent;
    var innerHTML = questionData.innerHTML;
    
    // Extract items from [[dN::text]] and [[d::text]] syntax
    var items = [];
    var regex = /\[\[d\d*::((?:(?!\]\])[\s\S])*)\]\]/g;
    var match;
    
    // Try HTML processing first for formatted items
    var useHtmlFormatting = false;
    if (innerHTML && innerHTML !== textContent) {
        try {
            // Extract items from HTML content
            var htmlItems = [];
            var htmlRegex = /\[\[d\d*::((?:(?!\]\])[\s\S])*)\]\]/g;
            var htmlMatch;
            
            while ((htmlMatch = htmlRegex.exec(innerHTML)) !== null) {
                var itemText = htmlMatch[1].trim();
                
                // Find the formatted version of this item in the HTML
                var formattedItem = extractFormattedItem(innerHTML, itemText);
                
                htmlItems.push({
                    text: itemText,
                    html: formattedItem
                });
            }
            
            if (htmlItems.length > 0) {
                items = htmlItems;
                useHtmlFormatting = true;
            }
        } catch (error) {
            // Fall back to text processing if HTML processing fails
            useHtmlFormatting = false;
        }
    }
    
    // Fallback to text processing if HTML processing failed or no formatting exists
    if (!useHtmlFormatting) {
        while ((match = regex.exec(textContent)) !== null) {
            items.push({
                text: match[1].trim(),
                html: match[1].trim()
            });
        }
    }
    
    // If no items found, show helpful message
    if (items.length === 0) {
        itemCollection.innerHTML = '<p style="color: #666; font-style: italic;">No draggable items found. Use the add-on to create [[d::text]] syntax.</p>';
        return;
    }
    
    // Shuffle items
    items = shuffleArray(items);
    
    // Create draggable elements
    itemCollection.innerHTML = '';
    items.forEach(function(item, index) {
        var itemElement = document.createElement('div');
        itemElement.className = 'draggable-item';
        itemElement.draggable = true;
        itemElement.innerHTML = sanitizeHtml(item.html);
        itemElement.setAttribute('data-item-text', item.text);
        itemElement.setAttribute('data-item-index', index);
        itemCollection.appendChild(itemElement);
    });
}

// Helper function to extract formatted item from HTML content
function extractFormattedItem(htmlContent, targetText) {
    // Simple approach: return the text as-is for now
    // In a full implementation, we'd need to parse HTML structure more carefully
    return targetText;
}

// Shuffle array utility
function shuffleArray(array) {
    var shuffled = array.slice();
    for (var i = shuffled.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = shuffled[i];
        shuffled[i] = shuffled[j];
        shuffled[j] = temp;
    }
    return shuffled;
}

// Reset study state
function resetStudyState() {
    studyState.userAnswers.clear();
    studyState.usedIds.clear();
    studyState.idGenerationLock = false;
}

// Attach drag and drop events
function attachDragAndDropEvents() {
    var itemCollection = document.getElementById('item-collection');
    var exerciseText = document.getElementById('exercise-text');
    
    // Draggable items events
    var items = itemCollection.querySelectorAll('.draggable-item');
    for (var i = 0; i < items.length; i++) {
        items[i].addEventListener('dragstart', handleDragStart);
        items[i].addEventListener('dragend', handleDragEnd);
    }
    
    // Drop zones events
    var dropZones = exerciseText.querySelectorAll('.answer-input');
    for (var i = 0; i < dropZones.length; i++) {
        dropZones[i].addEventListener('dragover', handleDragOver);
        dropZones[i].addEventListener('dragenter', handleDragEnter);
        dropZones[i].addEventListener('dragleave', handleDragLeave);
        dropZones[i].addEventListener('drop', handleDrop);
        dropZones[i].addEventListener('click', handleDropZoneClick);
    }
}

// Attach control events
function attachControlEvents() {
    var showAnswersBtn = document.getElementById('show-answers-btn');
    var resetBtn = document.getElementById('reset-btn');
    
    showAnswersBtn.addEventListener('click', showAnswers);
    resetBtn.addEventListener('click', resetStudy);
}

// Drag and drop event handlers
function handleDragStart(e) {
    e.dataTransfer.setData('text/plain', e.target.getAttribute('data-item-text'));
    e.dataTransfer.setData('item-index', e.target.getAttribute('data-item-index'));
    e.dataTransfer.setData('item-html', e.target.innerHTML);
    e.target.classList.add('dragging');
}

function handleDragEnd(e) {
    e.target.classList.remove('dragging');
}

function handleDragOver(e) {
    e.preventDefault();
}

function handleDragEnter(e) {
    e.preventDefault();
    e.target.classList.add('drag-over');
}

function handleDragLeave(e) {
    e.target.classList.remove('drag-over');
}

function handleDrop(e) {
    e.preventDefault();
    e.target.classList.remove('drag-over');
    
    var itemText = e.dataTransfer.getData('text/plain');
    var itemHtml = e.dataTransfer.getData('item-html');
    var itemIndex = e.dataTransfer.getData('item-index');
    var blankId = e.target.getAttribute('data-blank-id');
    
    // Fill the drop zone with sanitized HTML content
    e.target.innerHTML = sanitizeHtml(itemHtml || itemText);
    e.target.classList.add('filled');
    
    // Mark item as used
    var itemCollection = document.getElementById('item-collection');
    var draggedItem = itemCollection.querySelector('[data-item-index="' + itemIndex + '"]');
    if (draggedItem) {
        draggedItem.classList.add('used');
    }
    
    // Store user answer
    studyState.userAnswers.set(blankId, itemText);
    
    // Remove previous answer if any
    var previousItem = itemCollection.querySelector('[data-item-text="' + itemText + '"]');
    if (previousItem && previousItem !== draggedItem) {
        previousItem.classList.remove('used');
    }
}

function handleDropZoneClick(e) {
    if (e.target.classList.contains('filled')) {
        // Remove item from drop zone
        var blankId = e.target.getAttribute('data-blank-id');
        var itemText = e.target.textContent || e.target.innerText;
        
        // Clear drop zone
        e.target.innerHTML = '';
        e.target.classList.remove('filled', 'correct', 'incorrect');
        
        // Unmark item as used
        var itemCollection = document.getElementById('item-collection');
        var item = itemCollection.querySelector('[data-item-text="' + itemText + '"]');
        if (item) {
            item.classList.remove('used');
        }
        
        // Remove from user answers
        studyState.userAnswers.delete(blankId);
    }
}


// Show answers
function showAnswers() {
    var exerciseText = document.getElementById('exercise-text');
    var itemCollection = document.getElementById('item-collection');
    
    // Process each blank with appropriate color coding
    studyState.correctAnswers.forEach(function(correctAnswer, blankId) {
        var dropZone = exerciseText.querySelector('[data-blank-id="' + blankId + '"]');
        var userAnswer = studyState.userAnswers.get(blankId);
        
        // Set the correct text with sanitized HTML formatting if available
        var formattedAnswer = extractFormattedItem(document.getElementById('question-data').innerHTML, correctAnswer);
        dropZone.innerHTML = sanitizeHtml(formattedAnswer);
        
        // Apply appropriate styling based on user's original answer
        dropZone.classList.remove('filled', 'correct', 'incorrect', 'auto-filled');
        
        if (!userAnswer) {
            // Empty blank - show in grey
            dropZone.classList.add('auto-filled');
        } else if (userAnswer === correctAnswer) {
            // User was correct - show in green
            dropZone.classList.add('correct');
        } else {
            // User was incorrect - show in pink/red
            dropZone.classList.add('incorrect');
        }
    });
    
    // Mark all items as used
    var items = itemCollection.querySelectorAll('.draggable-item');
    for (var i = 0; i < items.length; i++) {
        items[i].classList.add('used');
    }
}


// Reset study
function resetStudy() {
    // Re-initialize entire study mode to restore original state
    initializeStudyMode();
    
    // Ensure item bank is visible
    var itemBank = document.querySelector('.item-bank');
    if (itemBank) {
        itemBank.style.display = 'block';
    }
}

// HTML sanitization function to prevent XSS attacks
function sanitizeHtml(text) {
    if (!text) return '';
    
    // Create a temporary div to leverage browser's HTML parsing
    var tempDiv = document.createElement('div');
    tempDiv.textContent = text;
    
    // Allow only safe HTML tags and attributes
    var allowedTags = ['b', 'i', 'u', 'em', 'strong', 'span', 'br'];
    var allowedAttributes = ['style'];
    
    // Simple whitelist-based sanitization
    var sanitized = tempDiv.innerHTML;
    
    // Remove script tags and event handlers
    sanitized = sanitized.replace(/<script[^>]*>.*?<\/script>/gi, '');
    sanitized = sanitized.replace(/on\w+\s*=\s*["'][^"']*["']/gi, '');
    sanitized = sanitized.replace(/javascript:/gi, '');
    sanitized = sanitized.replace(/data:/gi, '');
    sanitized = sanitized.replace(/vbscript:/gi, '');
    
    return sanitized;
}

// Edge case validation for malformed patterns
function validateAndSanitizePattern(text) {
    if (!text || typeof text !== 'string') {
        return '';
    }
    
    // Check for extremely long text (potential DoS)
    if (text.length > 10000) {
        console.warn('Pattern text too long, truncating');
        text = text.substring(0, 10000);
    }
    
    // Check for deeply nested brackets (potential ReDoS)
    var bracketDepth = 0;
    var maxDepth = 10;
    for (var i = 0; i < text.length; i++) {
        if (text[i] === '[') bracketDepth++;
        if (text[i] === ']') bracketDepth--;
        if (bracketDepth > maxDepth) {
            console.warn('Pattern contains deeply nested brackets, sanitizing');
            return text.replace(/\[{3,}/g, '[[').replace(/\]{3,}/g, ']]');
        }
    }
    
    // Validate pattern structure
    var malformedPatterns = [
        /\[\[d[^\]]*\[\[/g,  // Nested opening brackets
        /\]\][^\[]*\]\]/g,   // Nested closing brackets
        /\[\[d[^:]*::[^:]*::/g, // Multiple colons
        /\[\[d\d{4,}/g       // Extremely long numbers
    ];
    
    for (var i = 0; i < malformedPatterns.length; i++) {
        if (malformedPatterns[i].test(text)) {
            console.warn('Malformed pattern detected, sanitizing');
            // Return safe fallback
            return text.replace(/\[\[d[^\]]*\]\]/g, '[MALFORMED_PATTERN]');
        }
    }
    
    return text;
}

// Initialize immediately - no event waiting
initializeStudyMode();

})();
</script>
{{/Question}}