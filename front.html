<div class="learning-interface">
    <!-- Main Content Area -->
    <main class="content-area">
        <div class="exercise-text" id="exercise-text">
            <!-- Text with form-like input elements -->
        </div>
        
        <div class="exercise-controls">
            <button class="action-btn primary" id="show-answers-btn">Show Answers</button>
            <button class="action-btn secondary" id="reset-btn">Reset</button>
        </div>
        
        <!-- Available Items - positioned below buttons -->
        <aside class="item-bank">
            <div class="item-collection" id="item-collection">
                <!-- Draggable items in horizontal layout -->
            </div>
        </aside>
    </main>
</div>

{{#Question}}
<!-- Store field content in hidden div -->
<div id="question-data" style="display: none;">{{Question}}</div>

<script>
(function() {
    // Global state for drag-and-drop functionality
    var studyState = {
        correctAnswers: new Map(),
        userAnswers: new Map(),
        // Group validation support
        answerGroups: new Map(),        // groupId → Set of acceptable answers
        blankGroupMapping: new Map(),   // blankId → groupId
        validationMode: 'positional'    // 'positional' or 'semantic'
    };

// Initialize study mode
function initializeStudyMode() {
    parseQuestion();
    createDraggableItems();
    resetStudyState();
    attachDragAndDropEvents();
    attachControlEvents();
}

// HTML sanitization helper function
function sanitizeHTML(html) {
    var temp = document.createElement('div');
    temp.textContent = html;
    return temp.innerHTML;
}

// Parse question field and create inline drop zones with semantic validation support
function parseQuestion() {
    var questionData = document.getElementById('question-data');
    var exerciseText = document.getElementById('exercise-text');
    
    if (!questionData || !exerciseText) {
        exerciseText.innerHTML = '<p style="color: red;">ERROR: Missing DOM elements</p>';
        return;
    }
    
    var textContent = questionData.textContent;
    var questionField = textContent;
    
    if (!questionField || questionField.trim() === '' || questionField === '{{Question}}') {
        exerciseText.innerHTML = '<p style="color: #666; font-style: italic;">No question content found. Please add content to your Question field.</p>';
        return;
    }
    
    // Clear all state
    studyState.correctAnswers.clear();
    studyState.answerGroups.clear();
    studyState.blankGroupMapping.clear();
    studyState.validationMode = 'positional';
    
    // Detect group syntax
    var hasGroupSyntax = /@\w+/.test(questionField);
    
    if (hasGroupSyntax) {
        studyState.validationMode = 'semantic';
        parseSemanticQuestion(questionField, exerciseText);
    } else {
        parsePositionalQuestion(questionField, exerciseText);
    }
}
    
function parseSemanticQuestion(questionField, exerciseText) {
    var nextAutoId = 1;
    var groupRegex = /\[\[d(\d*)::([^\]]+)\]\](@\w+)?/g;
    var match;
    
    // First pass: find max existing ID
    var maxNum = 0;
    questionField.replace(groupRegex, function(match, num) {
        if (num && num.length > 0) {
            maxNum = Math.max(maxNum, parseInt(num));
        }
    });
    nextAutoId = maxNum + 1;
    
    // Second pass: process with group support
    var processedHTML = questionField.replace(groupRegex, function(match, num, answerText, groupSyntax) {
        var blankId = num && num.length > 0 ? 'd' + num : 'd' + nextAutoId++;
        
        // Security fix: sanitize answer text
        var sanitizedAnswer = sanitizeHTML(answerText);
        studyState.correctAnswers.set(blankId, sanitizedAnswer);
        
        // Handle group syntax
        if (groupSyntax) {
            var groupId = groupSyntax.substring(1); // Remove @
            
            // Map blank to group
            studyState.blankGroupMapping.set(blankId, groupId);
            
            // Add answer to group
            if (!studyState.answerGroups.has(groupId)) {
                studyState.answerGroups.set(groupId, new Set());
            }
            studyState.answerGroups.get(groupId).add(sanitizedAnswer);
        }
        
        return '<span class="answer-input" data-blank-id="' + blankId + '"></span>';
    });
    
    exerciseText.innerHTML = processedHTML;
}

function parsePositionalQuestion(questionField, exerciseText) {
    // Existing logic for backward compatibility
    var nextAutoId = 1;
    var regex = /\[\[d(\d*)::([^\]]+)\]\]/g;
    
    // Find max existing number
    var maxNum = 0;
    questionField.replace(regex, function(match, num) {
        if (num && num.length > 0) {
            maxNum = Math.max(maxNum, parseInt(num));
        }
    });
    nextAutoId = maxNum + 1;
    
    var processedHTML = questionField.replace(regex, function(match, num, answerText) {
        var blankId = num && num.length > 0 ? 'd' + num : 'd' + nextAutoId++;
        var sanitizedAnswer = sanitizeHTML(answerText);
        studyState.correctAnswers.set(blankId, sanitizedAnswer);
        return '<span class="answer-input" data-blank-id="' + blankId + '"></span>';
    });
    
    if (processedHTML === questionField) {
        processedHTML = questionField + '<br><br><em style="color: #666;">No drag-drop blanks found. Use the add-on to create [[d::text]] syntax.</em>';
    }
    
    exerciseText.innerHTML = processedHTML;
}

// Create draggable items with group syntax cleaning
function createDraggableItems() {
    var questionData = document.getElementById('question-data');
    var itemCollection = document.getElementById('item-collection');
    
    if (!questionData || !itemCollection) {
        return;
    }
    
    var items = [];
    var itemRegex = /\[\[d(\d*)::([^\]]+)\]\](@\w+)?/g;
    var questionField = questionData.textContent;
    var match;
    
    while ((match = itemRegex.exec(questionField)) !== null) {
        var answerText = match[2];
        // Clean text - remove group syntax from display, sanitize
        var cleanText = sanitizeHTML(answerText);
        items.push(cleanText);
    }
    
    // If no items found, show helpful message
    if (items.length === 0) {
        itemCollection.innerHTML = '<p style="color: #666; font-style: italic;">No draggable items found. Use the add-on to create [[d::text]] syntax.</p>';
        return;
    }
    
    // Remove duplicates and shuffle
    items = [...new Set(items)];
    items = shuffleArray(items);
    
    // Create draggable elements
    itemCollection.innerHTML = '';
    items.forEach(function(item, index) {
        var itemElement = document.createElement('div');
        itemElement.className = 'draggable-item';
        itemElement.draggable = true;
        itemElement.textContent = item; // Use textContent for security
        itemElement.setAttribute('data-item-text', item);
        itemElement.setAttribute('data-item-index', index);
        itemCollection.appendChild(itemElement);
    });
}


// Shuffle array utility
function shuffleArray(array) {
    var shuffled = array.slice();
    for (var i = shuffled.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = shuffled[i];
        shuffled[i] = shuffled[j];
        shuffled[j] = temp;
    }
    return shuffled;
}

// Reset study state
function resetStudyState() {
    studyState.userAnswers.clear();
}

// Attach drag and drop events
function attachDragAndDropEvents() {
    var itemCollection = document.getElementById('item-collection');
    var exerciseText = document.getElementById('exercise-text');
    
    // Draggable items events
    var items = itemCollection.querySelectorAll('.draggable-item');
    for (var i = 0; i < items.length; i++) {
        items[i].addEventListener('dragstart', handleDragStart);
        items[i].addEventListener('dragend', handleDragEnd);
    }
    
    // Drop zones events
    var dropZones = exerciseText.querySelectorAll('.answer-input');
    for (var i = 0; i < dropZones.length; i++) {
        dropZones[i].addEventListener('dragover', handleDragOver);
        dropZones[i].addEventListener('dragenter', handleDragEnter);
        dropZones[i].addEventListener('dragleave', handleDragLeave);
        dropZones[i].addEventListener('drop', handleDrop);
        dropZones[i].addEventListener('click', handleDropZoneClick);
    }
}

// Attach control events
function attachControlEvents() {
    var showAnswersBtn = document.getElementById('show-answers-btn');
    var resetBtn = document.getElementById('reset-btn');
    
    showAnswersBtn.addEventListener('click', showAnswers);
    resetBtn.addEventListener('click', resetStudy);
}

// Drag and drop event handlers
function handleDragStart(e) {
    e.dataTransfer.setData('text/plain', e.target.getAttribute('data-item-text'));
    e.dataTransfer.setData('item-index', e.target.getAttribute('data-item-index'));
    e.target.classList.add('dragging');
}

function handleDragEnd(e) {
    e.target.classList.remove('dragging');
}

function handleDragOver(e) {
    e.preventDefault();
}

function handleDragEnter(e) {
    e.preventDefault();
    e.target.classList.add('drag-over');
}

function handleDragLeave(e) {
    e.target.classList.remove('drag-over');
}

function handleDrop(e) {
    e.preventDefault();
    e.target.classList.remove('drag-over');
    
    var itemText = e.dataTransfer.getData('text/plain');
    var itemIndex = e.dataTransfer.getData('item-index');
    var blankId = e.target.getAttribute('data-blank-id');
    
    // Security fix: use textContent instead of innerHTML
    e.target.textContent = itemText;
    e.target.classList.add('filled');
    
    // Mark item as used
    var itemCollection = document.getElementById('item-collection');
    var draggedItem = itemCollection.querySelector('[data-item-index="' + itemIndex + '"]');
    if (draggedItem) {
        draggedItem.classList.add('used');
    }
    
    // Store user answer (sanitized)
    studyState.userAnswers.set(blankId, sanitizeHTML(itemText));
    
    // Remove previous answer if any
    var previousItem = itemCollection.querySelector('[data-item-text="' + itemText + '"]');
    if (previousItem && previousItem !== draggedItem) {
        previousItem.classList.remove('used');
    }
}

function handleDropZoneClick(e) {
    if (e.target.classList.contains('filled')) {
        // Remove item from drop zone
        var blankId = e.target.getAttribute('data-blank-id');
        var itemText = e.target.textContent || e.target.innerText;
        
        // Clear drop zone
        e.target.textContent = '';
        e.target.classList.remove('filled', 'correct', 'incorrect');
        
        // Unmark item as used
        var itemCollection = document.getElementById('item-collection');
        var item = itemCollection.querySelector('[data-item-text="' + itemText + '"]');
        if (item) {
            item.classList.remove('used');
        }
        
        // Remove from user answers
        studyState.userAnswers.delete(blankId);
    }
}


// Enhanced validation with semantic support
function validateUserAnswer(blankId, userAnswer) {
    if (studyState.validationMode === 'semantic' && studyState.blankGroupMapping.has(blankId)) {
        // Semantic validation: check if answer is acceptable for this blank's group
        var groupId = studyState.blankGroupMapping.get(blankId);
        var acceptableAnswers = studyState.answerGroups.get(groupId);
        
        if (acceptableAnswers && acceptableAnswers.has(userAnswer)) {
            return true;
        }
    }
    
    // Positional validation fallback
    var correctAnswer = studyState.correctAnswers.get(blankId);
    return userAnswer === correctAnswer;
}

// Show answers with semantic validation support
function showAnswers() {
    var exerciseText = document.getElementById('exercise-text');
    var itemCollection = document.getElementById('item-collection');
    
    // Hide item collection and show answers button
    if (itemCollection) itemCollection.style.display = 'none';
    var showAnswersBtn = document.getElementById('show-answers-btn');
    if (showAnswersBtn) showAnswersBtn.style.display = 'none';
    
    // Process each blank with appropriate color coding
    studyState.correctAnswers.forEach(function(correctAnswer, blankId) {
        var dropZone = exerciseText.querySelector('[data-blank-id="' + blankId + '"]');
        var userAnswer = studyState.userAnswers.get(blankId);
        
        if (!dropZone) return;
        
        // Set the correct answer text (already sanitized)
        dropZone.textContent = correctAnswer;
        
        // Apply appropriate styling based on user's original answer
        dropZone.classList.remove('filled', 'correct', 'incorrect', 'auto-filled');
        
        if (!userAnswer) {
            // Empty blank - show in grey
            dropZone.classList.add('auto-filled');
        } else {
            // Use enhanced validation
            var isCorrect = validateUserAnswer(blankId, userAnswer);
            
            if (isCorrect) {
                // User was correct - show in green
                dropZone.classList.add('correct');
            } else {
                // User was incorrect - show in pink/red
                dropZone.classList.add('incorrect');
            }
        }
    });
    
    // Mark all items as used
    var items = itemCollection.querySelectorAll('.draggable-item');
    for (var i = 0; i < items.length; i++) {
        items[i].classList.add('used');
    }
}


// Reset study
function resetStudy() {
    // Re-initialize entire study mode to restore original state
    initializeStudyMode();
    
    // Ensure item bank is visible
    var itemBank = document.querySelector('.item-bank');
    if (itemBank) {
        itemBank.style.display = 'block';
    }
}

// Initialize immediately - no event waiting
initializeStudyMode();

})();
</script>
{{/Question}}